#!/usr/bin/env ruby
require 'gli'
require 'suploy-scli'

#rescue LoadError
#  STDERR.puts "In development, you need to use `bundle exec bin/suploy-scli` to run your app"
#  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
#  STDERR.puts "Feel free to remove this message from bin/suploy-scli now"
#  exit 64
#end

include GLI::App

program_desc 'A commandlineinterface for managing a suploy server'

version SuployScli::VERSION

desc 'manage SSH Keys'
command :ssh do |c|


  c.desc "Add a SSH Key to a user"
  c.arg_name '<username> <sshkey_name> <sshkey>'
  c.command :add do |add| 
    add.action do |global_options,options, args|
      if args.size == 3
         user        = args[0]
         sshkey_name = args[1]
         sshkey      = args[2]
         if @ssh_keys.add_ssh_key(user, sshkey_name, sshkey)
           puts "SSH-Key #{sshkey_name} added for #{user}"
         else 
           STDERR.puts "ERROR: Cannot add SSH-Key"
         end
      else
         STDERR.puts "ERROR: Wrong number of arguments"
      end
    end
  end


  c.desc "removes a ssh-key from a user"
  c.command :rm do |rm| 
    rm.action do |global_options,options,args|
      if args.size == 2
         @ssh_keys.remove_ssh_key(args[0], args[1])
      end
    end
  end

end

desc 'manage repositoryis'
arg_name 'Describe arguments to add here'
command :repo do |c|


  c.desc "adds a repository to suploy"
  c.command :add do |add| 
    add.action do |global_options,options,args|
      if args.size == 2
         @repo.add_repository(args[0], args[1])
      end
    end
  end

  c.desc "removes a repository from suploy"
  c.command :rm do |rm| 
    rm.action do |global_options,options,args|
      if args.size == 1
         @repo.remove_repository(args[0])
      end
    end
  end

  c.desc "manage user of a repository"
  c.command :user do |user| 
    user.command :add do |add|
      add.action do |global_options,options,args|
        if args.size == 2
           @repo.add_user_to_repository(args[0], args[1])
        end
      end
    end

    user.command :rm do |rm|
      rm.action do |global_options,options,args|
        if args.size == 2
           @repo.remove_user_from_repository(args[0], args[1])
        end
      end
    end
  end

end

desc 'manage suploy container'
arg_name 'Describe arguments to complete here'
command :container do |c|

  c.desc ""
  c.command :start do |start| 
    start.action do |global_options,options,args|
      if args.size == 1
         @container.start_container(args[0])
      end
    end
  end
  

  c.desc "stop a running container"
  c.command :stop do |stop| 
    stop.action do |global_options,options,args|
      if args.size == 1
         @container.stop_container(args[0])
      end
    end
  end

  c.desc "Views information about a container"
  c.command :view do |view| 
    view.action do |global_options,options,args|
      if args.size == 0 
         ugly_json = @container.scli.view_all_container()
         puts JSON::pretty_generate(ugly_json)
      end
      if args.size == 1
         ugly_json = @container.scli.view_container(args[0])
         puts JSON::pretty_generate(ugly_json)
      end
    end
  end
end

desc 'Handle docker database containers'
command :database do |c|
  c.desc 'create a new database container'
  c.command :create do |create|
    create.action do |global_options,options,args|
      puts "Creating a database just for you. Hang on a second..."
      puts @database.database_create
    end
  end
  c.desc 'show all database containers'
  c.command :list do |list|
    list.action do |global_options,options,args|
      puts "list all containers here"
    end
  end
end

pre do |global,command,options,args|
  gitolite_dir = '/home/vagrant/gitolite-admin'
  git_repo_dir = '/home/git/repositories'
  @ssh_keys = Scli::ScliSSHKey.new(gitolite_dir)
  @container = Scli::Container.new
  @repo = Scli::Repo.new(gitolite_dir, git_repo_dir)
  @database = Scli::Database.new

  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
